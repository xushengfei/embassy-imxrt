//! FlexSPI NOR Storage Bus Driver module for the NXP RT6xx family of microcontrollers
//!
use cortex_m::asm;
use embassy_hal_internal::Peripheral;
use mimxrt600_fcb::FlexSpiLutOpcode;
use mimxrt600_fcb::FlexSpiLutOpcode::*;
use storage_bus::nor::{
    BlockingNorStorageBusDriver, NorStorageBusError, NorStorageBusWidth, NorStorageCmd, NorStorageCmdMode,
    NorStorageCmdType, NorStorageDummyCycles,
};

use crate::clocks::enable_and_reset;
use crate::iopctl::IopctlPin as Pin;
use crate::pac::flexspi::ahbcr::*;
use crate::pac::flexspi::flshcr1::*;
use crate::pac::flexspi::flshcr2::*;
use crate::pac::flexspi::mcr0::*;
use crate::pac::flexspi::mcr2::*;
use crate::{interrupt, peripherals};

static MAX_FLEXSPI_TRANSFER_SIZE: u32 = 128;

#[derive(Clone, Copy, Debug)]
/// FlexSPI Port Enum.
pub enum FlexSpiFlashPort {
    /// FlexSPI Port A
    PortA,
    /// FlexSPI Port B
    PortB,
}

#[derive(Clone, Copy, Debug)]
/// FlexSPI Flash Port Device Instance Enum.
pub enum FlexSpiFlashPortDeviceInstance {
    /// Device Instance 0
    DeviceInstance0,
    /// Device Instance 1
    DeviceInstance1,
}

#[derive(Clone, Copy, Debug)]
/// FlexSPI Bus Width Enum.
pub enum FlexSpiBusWidth {
    /// Single bit bus width
    Single,
    /// Dual bit bus width
    Dual,
    /// Quad bit bus width
    Quad,
    /// Octal bit bus width
    Octal,
}

// Transfer Command Error Bits Enum.
// TODO - Does implementing From trait makes more sense here?
enum TransferCmdErrorBits {
    IpCmdError = 3,
    AhbCmdError = 4,
    SeqTimeOut = 11,
    AhbBusTimeout = 10,
    DataLearnFail = 7,
    IpCmdGrantTimeout = 1,
    AhbCmdGrantTimeout = 2,
}

#[derive(Clone, Copy, Debug)]
/// FlexSPI Chip Select Interval unit Enum.
pub enum FlexspiCsIntervalCycleUnit {
    /// CS interval unit is 1 cycle
    CsIntervalUnit1Cycle,
    /// CS interval unit is 256 cycle
    CsIntervalUnit256Cycle,
}
#[derive(Clone, Copy, Debug)]
/// FlexSPI AHB Write Wait unit Enum.
pub enum FlexspiAhbWriteWaitUnit {
    /// AWRWAIT unit is 2 ahb clock cycle
    FlexspiAhbWriteWaitUnit2ahbCycle,
    /// AWRWAIT unit is 8 ahb clock cycle.
    FlexspiAhbWriteWaitUnit8ahbCycle,
    /// AWRWAIT unit is 32 ahb clock cycle.
    FlexspiAhbWriteWaitUnit32ahbCycle,
    /// AWRWAIT unit is 128 ahb clock cycle.   
    FlexspiAhbWriteWaitUnit128ahbCycle,
    /// AWRWAIT unit is 512 ahb clock cycle.   
    FlexspiAhbWriteWaitUnit512ahbCycle,
    /// AWRWAIT unit is 2048 ahb clock cycle.  
    FlexspiAhbWriteWaitUnit2048ahbCycle,
    /// AWRWAIT unit is 8192 ahb clock cycle.  
    FlexspiAhbWriteWaitUnit8192ahbCycle,
    /// AWRWAIT unit is 32768 ahb clock cycle.
    FlexspiAhbWriteWaitUnit32768ahbCycle,
}

#[derive(Clone, Copy, Debug)]
/// FlexSPI Read Sample Clock Enum.
pub enum FlexspiReadSampleClock {
    /// Dummy Read strobe generated by FlexSPI self.flexspi_ref and loopback internally
    FlexspiReadSampleClkLoopbackInternally,
    /// Dummy Read strobe generated by FlexSPI self.flexspi_ref and loopback from DQS pad
    FlexspiReadSampleClkLoopbackFromDqsPad,
    /// SCK output clock and loopback from SCK pad
    FlexspiReadSampleClkLoopbackFromSckPad,
    /// Flash provided Read strobe and input from DQS pad
    FlexspiReadSampleClkExternalInputFromDqsPad,
}

#[derive(Clone, Copy, Debug)]
/// FlexSPI AHB Buffer Configuration structure
pub struct FlexspiAhbBufferConfig {
    /// This priority for AHB Master Read which this AHB RX Buffer is assigned.
    pub priority: u8,
    /// AHB Master ID the AHB RX Buffer is assigned.       
    pub master_index: u8,
    /// AHB buffer size in byte.   
    pub buffer_size: u16,
    /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master, allows to prefetch data for AHB read access.
    pub enable_prefetch: bool,
}

#[derive(Clone, Copy, Debug)]
/// Flash Device configuration
pub struct FlexspiDeviceConfig {
    /// FLEXSPI serial root clock
    pub flexspi_root_clk: u32,
    /// FLEXSPI use SCK2
    pub is_sck2_enabled: bool,
    /// Flash size in KByte
    pub flash_size_kb: u32,
    /// CS interval unit, 1 or 256 cycle
    pub cs_interval_unit: Csintervalunit,
    /// CS line assert interval, multiply CS interval unit to get the CS line assert interval cycles
    pub cs_interval: u16,
    /// CS line hold time
    pub cs_hold_time: u8,
    /// CS line setup time
    pub cs_setup_time: u8,
    /// Data valid time for external device                          
    pub data_valid_time: u8,
    /// Column space size                       
    pub columnspace: u8,
    /// If enable word address                        
    pub enable_word_address: bool,
    /// Sequence ID for AHB write command                    
    pub awr_seq_index: u8,
    /// Sequence number for AHB write command
    pub awr_seq_number: u8,
    /// Sequence ID for AHB read command                       
    pub ard_seq_index: u8,
    /// Sequence number for AHB read command
    pub ard_seq_number: u8,
    /// AHB write wait unit
    pub ahb_write_wait_unit: Awrwaitunit,
    /// AHB write wait interval, multiply AHB write interval unit to get the AHB write wait cycles
    pub ahb_write_wait_interval: u16,
    /// Enable/Disable FLEXSPI drive DQS pin as write mask
    pub enable_write_mask: bool,
}

#[derive(Clone, Copy, Debug)]
/// AHB configuration structure
pub struct AhbConfig {
    /// Enable AHB bus write access to IP TX FIFO.
    pub enable_ahb_write_ip_tx_fifo: bool,
    /// Enable AHB bus write access to IP RX FIFO.
    pub enable_ahb_write_ip_rx_fifo: bool,
    /// Timeout wait cycle for AHB command grant, timeout after ahbGrantTimeoutCyle*1024 AHB clock cycles.
    pub ahb_grant_timeout_cycle: u8,
    /// Timeout wait cycle for AHB read/write access, timeout after ahbBusTimeoutCycle*1024 AHB clock cycles.
    pub ahb_bus_timeout_cycle: u16,
    /// Wait cycle for idle state before suspended command sequence resume, timeout after ahbBusTimeoutCycle AHB clock cycles.
    pub resume_wait_cycle: u8,
    /// AHB buffer size.
    pub buffer: [FlexspiAhbBufferConfig; 8],
    /// Enable/disable automatically clean AHB RX Buffer and TX Buffer when FLEXSPI returns STOP mode ACK.
    pub enable_clear_ahb_buffer_opt: Clrahbbufopt,
    /// Enable/disable remove AHB read burst start address alignment limitation. when enable, there is no AHB read burst start address alignment limitation.
    pub enable_read_address_opt: Readaddropt,
    /// Enable/disable AHB read prefetch feature, when enabled, FLEXSPI will fetch more data than current AHB burst.
    pub enable_ahb_prefetch: bool,
    /// Enable/disable AHB bufferable write access support, when enabled, FLEXSPI return before waiting for command execution finished.
    pub enable_ahb_bufferable: Bufferableen,
    /// Enable AHB bus cachable read access support.
    pub enable_ahb_cachable: Cachableen,
}

#[derive(Clone, Copy, Debug)]
/// FlexSPI configuration structure
pub struct FlexspiConfig {
    /// Sample Clock source selection for Flash Reading.
    pub rx_sample_clock: Rxclksrc,
    /// Enable/disable SCK output free-running.
    pub enable_sck_free_running: Sckfreerunen,
    /// Enable/disable combining PORT A and B Data Pins (SIOA[3:0] and SIOB[3:0]) to support Flash Octal mode.
    pub enable_combination: bool,
    /// Enable/disable doze mode support.
    pub enable_doze: Dozeen,
    /// Enable/disable divide by 2 of the clock for half speed commands.
    pub enable_half_speed_access: Hsen,
    /// Enable/disable SCKB pad use as SCKA differential clock output, when enable, Port B flash access is not available.
    pub enable_sck_b_diff_opt: Sckbdiffopt,
    /// Enable/disable same configuration for all connected devices when enabled, same configuration in FLASHA1CRx is applied to all.
    pub enable_same_config_for_all: Samedeviceen,
    /// Timeout wait cycle for command sequence execution, timeout after ahbGrantTimeoutCyle*1024 serial root clock cycles.
    pub seq_timeout_cycle: u16,
    /// Timeout wait cycle for IP command grant, timeout after ipGrantTimeoutCycle*1024 AHB clock cycles.
    pub ip_grant_timeout_cycle: u8,
    /// FLEXSPI IP transmit watermark value.
    pub tx_watermark: usize,
    /// FLEXSPI receive watermark value.
    pub rx_watermark: usize,
    /// AHB configuration
    pub ahb_config: AhbConfig,
}

mod sealed {
    /// simply seal a trait
    pub trait Sealed {}
}

impl<T> sealed::Sealed for T {}

struct Info {
    regs: &'static crate::pac::flexspi::RegisterBlock,
}

trait SealedInstance {
    fn info() -> Info;
}
/// Instance trait to be used for instanciating for FlexSPI HW instance
#[allow(private_bounds)]
pub trait Instance: SealedInstance + Peripheral<P = Self> + 'static + Send {
    /// Interrupt for this SPI instance.
    type Interrupt: interrupt::typelevel::Interrupt;
}

impl SealedInstance for crate::peripherals::FLEXSPI {
    fn info() -> Info {
        Info {
            regs: unsafe { &*crate::pac::Flexspi::ptr() },
        }
    }
}

impl Instance for crate::peripherals::FLEXSPI {
    type Interrupt = crate::interrupt::typelevel::FLEXSPI;
}
/// Driver mode.
#[allow(private_bounds)]
pub trait Mode: sealed::Sealed {}

/// Blocking mode.
pub struct Blocking;
impl Mode for Blocking {}

/// Async mode.
pub struct Async;
impl Mode for Async {}

#[allow(private_interfaces)]
/// FlexSPI Configuration Manager Port
pub struct FlexSpiConfigurationPort {
    /// Bus Width
    _bus_width: FlexSpiBusWidth,
    /// Flash Port
    flash_port: FlexSpiFlashPort,
    /// Device Instance
    device_instance: FlexSpiFlashPortDeviceInstance,
    /// FlexSPI HW Info Object
    info: Info,
}

/// FlexSPI instance
pub struct FlexspiNorStorageBus<M: Mode> {
    /// FlexSPI HW Info Object
    info: Info,
    /// RX FIFO watermark level
    rx_watermark: u8,
    /// TX FIFO Watermark Level
    tx_watermark: u8,
    /// Mode Phantom object
    _mode: core::marker::PhantomData<M>,
    /// FlexSPI Configuration Port
    pub configport: FlexSpiConfigurationPort,
}

// LUT instruction pointer to be used during LUT programming
struct LutInstrCookie {
    seq_num: usize,
    instr_num: usize,
}

impl LutInstrCookie {
    fn next_instruction(&mut self) {
        if self.instr_num == 1 {
            self.seq_num += 1;
            self.instr_num = 0;
        } else {
            self.instr_num += 1;
        }
    }
}

#[derive(Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[allow(non_snake_case)]
enum FlexSpiError {
    /// Flash command grant error
    CmdGrantErr {
        /// AHB read command error
        AhbReadCmdErr: bool,
        /// AHB write command error
        AhbWriteCmdErr: bool,
        /// IP command error
        IpCmdErr: bool,
    }, // INTR[AHBCMDGE] = 1 / INTR[IPCMDGE] = 1
    /// Flash command check error
    CmdCheckErr {
        /// AHB read command error
        AhbReadCmdErr: bool,
        /// AHB write command error
        AhbWriteCmdErr: bool,
        /// IP command error
        IpCmdErr: bool,
    }, // INTR[AHBCMDERR] = 1/ INTR[IPCMDERR] = 1
    /// Flash command execution error
    CmdExecErr {
        /// AHB read command error
        AhbReadCmdErr: bool,
        /// AHB write command error
        AhbWriteCmdErr: bool,
        /// IP command error
        IpCmdErr: bool,
    }, // INTR[AHBCMDERR] = 1/ INTR[SEQTIMEOUT] = 1/ INTR[IPCMDERR] = 1
    /// AHB bus timeout error
    AhbBusTimeout {
        /// AHB read command error
        AhbReadCmdErr: bool, // INTR[AHBBUSTIMEO UT] = 1
        /// AHB write command error
        AhbWriteCmdErr: bool, // INTR[AHBBUSTIMEO UT] = 1
    },
    /// Data learning failed
    DataLearningFailed, // INTR[DATALEARNFAIL] = 1
}

impl FlexSpiError {
    /// Get the description of the error
    pub fn describe<'a, M: Mode>(&self, flexspi: &'a FlexspiNorStorageBus<M>) {
        match self {
            FlexSpiError::CmdGrantErr {
                AhbReadCmdErr,
                AhbWriteCmdErr,
                IpCmdErr,
            } => {
                if *AhbReadCmdErr {
                    info!("AHB bus error response for Read Command. Command grant timeout");
                }
                if *AhbWriteCmdErr {
                    info!("AHB bus error response for Write Command. Command grant timeout");
                }
                if *IpCmdErr {
                    info!("IP command grant timeout. Command grant timeout");
                }
            }
            FlexSpiError::CmdCheckErr {
                AhbReadCmdErr,
                AhbWriteCmdErr,
                IpCmdErr,
            } => {
                if *AhbWriteCmdErr {
                    info!(
                        "LUT sequence ID = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrid().bits()
                    );

                    info!(
                        "Sequnce Error Code = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrcode().bits()
                    );
                    info!("Command is not executed when error detected in command check. Following are the possible reasons:
                    - AHB write command with JMP_ON_CS instruction used in the sequence
                    - There is unknown instruction opcode in the sequence.
                    - Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
                    - Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.");
                }
                if *AhbReadCmdErr {
                    info!(
                        "LUT sequence ID = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrid().bits()
                    );

                    info!(
                        "Sequnce Error Code = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrcode().bits()
                    );
                    info!("Command is not executed when error detected in command check. Following are the possible reasons:
                    - There is unknown instruction opcode in the sequence
                    - Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
                    - Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.");
                }
                if *IpCmdErr {
                    info!(
                        "LUT sequence ID = {:08X}",
                        flexspi.info.regs.sts1().read().ipcmderrid().bits()
                    );

                    info!(
                        "Sequnce Error Code = {:08X}",
                        flexspi.info.regs.sts1().read().ipcmderrcode().bits()
                    );

                    info!("Command is not executed when error detected in command check. Following are the possible reasons:
                    - IP command with JMP_ON_CS instruction used in the sequence
                    - There is unknown instruction opcode in the sequence.
                    - Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence
                    - Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence
                    - Flash boundary across");
                }
            }
            FlexSpiError::CmdExecErr {
                AhbReadCmdErr,
                AhbWriteCmdErr,
                IpCmdErr,
            } => {
                if *AhbWriteCmdErr {
                    info!(
                        "LUT sequence ID = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrid().bits()
                    );

                    info!(
                        "Sequnce Error Code = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrcode().bits()
                    );
                    info!(
                        "There will be AHB bus error response except the following cases: 
                        - AHB write command is triggered by flush (INCR burst ended with AHB_TX_BUF not empty)
                        - AHB bufferable write access and bufferable enabled (AHBCR[BUFFERABLEEN]=0x1)
                    Following are possible reasons for this error - 
                        - Command timeout during execution"
                    );
                }
                if *AhbReadCmdErr {
                    info!(
                        "LUT sequence ID = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrid().bits()
                    );

                    info!(
                        "Sequnce Error Code = {:08X}",
                        flexspi.info.regs.sts1().read().ahbcmderrcode().bits()
                    );
                    info!(
                        "There will be AHB bus error response. Following are possible reasons for this error - 
                        - Command timeout during execution"
                    );
                }
                if *IpCmdErr {
                    info!(
                        "LUT sequence ID = {:08X}",
                        flexspi.info.regs.sts1().read().ipcmderrid().bits()
                    );

                    info!(
                        "Sequnce Error Code = {:08X}",
                        flexspi.info.regs.sts1().read().ipcmderrcode().bits()
                    );
                    info!(
                        "Following are possible reasons for this error - 
                        - Command timeout during execution"
                    );
                }
            }
            FlexSpiError::AhbBusTimeout {
                AhbReadCmdErr,
                AhbWriteCmdErr,
            } => {
                if *AhbReadCmdErr || *AhbWriteCmdErr {
                    info!(
                        "There will be AHB bus error response. Following are possible reasons for this error - 
                        - AHB bus timeout (no bus ready return)"
                    );
                } else {
                    info!("Unknown AHB bus timeout error");
                }
            }
            FlexSpiError::DataLearningFailed => info!("Data learning failed"),
        }
    }
}

impl BlockingNorStorageBusDriver for FlexspiNorStorageBus<Blocking> {
    fn send_command(
        &mut self,
        cmd: NorStorageCmd,
        read_buf: Option<&mut [u8]>,
        write_buf: Option<&[u8]>,
    ) -> Result<(), NorStorageBusError> {
        // Setup the transfer to be sent of the FlexSPI IP Port
        self.setup_ip_transfer(2, cmd.addr, cmd.data_bytes);

        // Program the LUT instructions for the command
        self.program_lut(&cmd, 2);

        // Start the transfer
        self.execute_ip_cmd();

        // Wait for command to complete
        // This wait is for FlexSPI to send the command to the Flash device
        // But the command completion in the flash needs to be checked separately by reading the status register of the flash device
        self.wait_for_cmd_completion();

        // Check for any errors during the transfer
        if let Err(status) = self.check_transfer_status() {
            status.describe(self);

            match status {
                FlexSpiError::AhbBusTimeout {
                    AhbReadCmdErr: _,
                    AhbWriteCmdErr: _,
                } => {
                    return Err(NorStorageBusError::StorageBusIoError);
                }
                FlexSpiError::CmdCheckErr {
                    AhbReadCmdErr: _,
                    AhbWriteCmdErr: _,
                    IpCmdErr: _,
                } => {
                    return Err(NorStorageBusError::StorageBusIoError);
                }
                FlexSpiError::CmdExecErr {
                    AhbReadCmdErr: _,
                    AhbWriteCmdErr: _,
                    IpCmdErr: _,
                } => {
                    return Err(NorStorageBusError::StorageBusIoError);
                }
                FlexSpiError::CmdGrantErr {
                    AhbReadCmdErr: _,
                    AhbWriteCmdErr: _,
                    IpCmdErr: _,
                } => {
                    return Err(NorStorageBusError::StorageBusNotAvailable);
                }
                FlexSpiError::DataLearningFailed => {
                    return Err(NorStorageBusError::StorageBusInternalError);
                }
            }
        }

        // For data transfer commands, read/write the data
        if let Some(data_cmd) = cmd.cmdtype {
            match data_cmd {
                NorStorageCmdType::Read => {
                    let buffer = read_buf.unwrap();
                    if let Some(mut size) = cmd.data_bytes {
                        if size > MAX_FLEXSPI_TRANSFER_SIZE {
                            let mut read_start_ptr: usize = 0;
                            loop {
                                self.read_cmd_data(
                                    MAX_FLEXSPI_TRANSFER_SIZE,
                                    &mut buffer[read_start_ptr..read_start_ptr + MAX_FLEXSPI_TRANSFER_SIZE as usize],
                                );
                                size -= MAX_FLEXSPI_TRANSFER_SIZE;
                                if size < MAX_FLEXSPI_TRANSFER_SIZE {
                                    break;
                                }
                                read_start_ptr += MAX_FLEXSPI_TRANSFER_SIZE as usize;
                            }
                            if size > 0 {
                                self.read_cmd_data(size, &mut buffer[read_start_ptr..]);
                            }
                        } else {
                            self.read_cmd_data(size, buffer);
                        }
                    }
                }
                NorStorageCmdType::Write => {
                    let buffer = write_buf.unwrap();
                    if let Some(mut size) = cmd.data_bytes {
                        if size > MAX_FLEXSPI_TRANSFER_SIZE {
                            let mut write_start_ptr: usize = 0;
                            loop {
                                self.write_cmd_data(
                                    MAX_FLEXSPI_TRANSFER_SIZE,
                                    &buffer[write_start_ptr..write_start_ptr + MAX_FLEXSPI_TRANSFER_SIZE as usize],
                                );
                                size -= MAX_FLEXSPI_TRANSFER_SIZE;
                                if size < MAX_FLEXSPI_TRANSFER_SIZE {
                                    break;
                                }
                                write_start_ptr += MAX_FLEXSPI_TRANSFER_SIZE as usize;
                            }
                            if size > 0 {
                                self.write_cmd_data(size, &buffer[write_start_ptr..]);
                            }
                        } else {
                            self.write_cmd_data(size, buffer);
                        }
                    }
                }
            }
        }
        Ok(())
    }
}

impl<M: Mode> FlexspiNorStorageBus<M> {
    fn setup_ip_transfer(&mut self, seq_id: u8, addr: Option<u32>, size: Option<u32>) {
        match addr {
            Some(addr) => {
                self.info.regs.ipcr0().modify(|_, w| unsafe { w.sfar().bits(addr) });
            }

            None => {
                self.info.regs.ipcr0().modify(|_, w| unsafe { w.sfar().bits(0) });
            }
        }

        // Set the Command sequence ID
        self.info.regs.ipcr1().modify(|_, w| unsafe { w.iseqid().bits(seq_id) });

        // Reset the sequence pointer
        self.info.regs.flshcr2(0).modify(|_, w| w.clrinstrptr().set_bit());
        self.info.regs.flshcr2(1).modify(|_, w| w.clrinstrptr().set_bit());
        self.info.regs.flshcr2(2).modify(|_, w| w.clrinstrptr().set_bit());
        self.info.regs.flshcr2(3).modify(|_, w| w.clrinstrptr().set_bit());

        // Disable DMA for TX and RX
        self.info.regs.iptxfcr().modify(|_, w| w.txdmaen().clear_bit());
        self.info.regs.iprxfcr().modify(|_, w| w.rxdmaen().clear_bit());

        // TODO: Set Tx and Rx watermark

        // Reset RX and TX FIFO
        self.info.regs.iprxfcr().modify(|_, w| w.clriprxf().set_bit());
        self.info.regs.iptxfcr().modify(|_, w| w.clriptxf().set_bit());

        // Set the data length
        // Max RX FIFO size is MAX_FLEXSPI_TRANSFER_SIZE bytes
        // TODO - We want to avoid RX FIFO overflow for now. We will revisit this later and increase the size
        // once we add overflow handling
        if let Some(size) = size {
            if size > MAX_FLEXSPI_TRANSFER_SIZE {
                self.info
                    .regs
                    .ipcr1()
                    .modify(|_, w| unsafe { w.idatsz().bits(MAX_FLEXSPI_TRANSFER_SIZE as u16) });
            } else {
                self.info
                    .regs
                    .ipcr1()
                    .modify(|_, w| unsafe { w.idatsz().bits(size as u16) });
            }
        }
    }

    fn execute_ip_cmd(&mut self) {
        self.info.regs.ipcmd().write(|w| w.trg().set_bit());
    }

    fn check_transfer_status(&self) -> Result<(), FlexSpiError> {
        let intr: u32 = self.info.regs.intr().read().bits();

        if intr & (1 << TransferCmdErrorBits::IpCmdError as u32) != 0 {
            self.info.regs.intr().modify(|_, w| w.ipcmderr().clear_bit_by_one());
            if intr & (1 << TransferCmdErrorBits::SeqTimeOut as u32) != 0 {
                return Err(FlexSpiError::CmdExecErr {
                    AhbReadCmdErr: false,
                    AhbWriteCmdErr: false,
                    IpCmdErr: true,
                });
            } else {
                return Err(FlexSpiError::CmdCheckErr {
                    AhbReadCmdErr: false,
                    AhbWriteCmdErr: false,
                    IpCmdErr: true,
                });
            }
        } else if intr & (1 << TransferCmdErrorBits::AhbCmdError as u32) != 0 {
            self.info.regs.intr().modify(|_, w| w.ahbcmderr().clear_bit_by_one());
            if intr & (1 << TransferCmdErrorBits::SeqTimeOut as u32) != 0 {
                return Err(FlexSpiError::CmdExecErr {
                    AhbReadCmdErr: true,
                    AhbWriteCmdErr: true,
                    IpCmdErr: false,
                });
            } else {
                return Err(FlexSpiError::CmdCheckErr {
                    AhbReadCmdErr: true,
                    AhbWriteCmdErr: true,
                    IpCmdErr: false,
                });
            }
        } else if intr & (1 << TransferCmdErrorBits::AhbBusTimeout as u32) != 0 {
            self.info
                .regs
                .intr()
                .modify(|_, w| w.ahbbustimeout().clear_bit_by_one());
            return Err(FlexSpiError::AhbBusTimeout {
                AhbReadCmdErr: true,
                AhbWriteCmdErr: true,
            });
        } else if intr & (1 << TransferCmdErrorBits::DataLearnFail as u32) != 0 {
            self.info
                .regs
                .intr()
                .modify(|_, w| w.datalearnfail().clear_bit_by_one());
            return Err(FlexSpiError::DataLearningFailed);
        } else if intr & (1 << TransferCmdErrorBits::IpCmdGrantTimeout as u32) != 0 {
            return Err(FlexSpiError::CmdGrantErr {
                AhbReadCmdErr: false,
                AhbWriteCmdErr: false,
                IpCmdErr: true,
            });
        } else if intr & (1 << TransferCmdErrorBits::AhbCmdGrantTimeout as u32) != 0 {
            self.info.regs.intr().modify(|_, w| w.ahbcmdge().clear_bit_by_one());
            return Err(FlexSpiError::CmdGrantErr {
                AhbReadCmdErr: true,
                AhbWriteCmdErr: true,
                IpCmdErr: false,
            });
        } else {
            return Ok(());
        }
    }

    fn write_even_instr(&self, seq_id: usize, opcode: FlexSpiLutOpcode, operand: u8, bus_width: u8) {
        self.info
            .regs
            .lut(seq_id)
            .modify(|_, w| unsafe { w.opcode0().bits(opcode as u8) });
        self.info
            .regs
            .lut(seq_id)
            .modify(|_, w| unsafe { w.num_pads0().bits(bus_width) });
        self.info
            .regs
            .lut(seq_id)
            .modify(|_, w| unsafe { w.operand0().bits(operand) });
    }

    fn write_odd_instr(&self, seq_id: usize, opcode: FlexSpiLutOpcode, operand: u8, bus_width: u8) {
        self.info
            .regs
            .lut(seq_id)
            .modify(|_, w| unsafe { w.opcode1().bits(opcode as u8) });
        self.info
            .regs
            .lut(seq_id)
            .modify(|_, w| unsafe { w.num_pads1().bits(bus_width) });
        self.info
            .regs
            .lut(seq_id)
            .modify(|_, w| unsafe { w.operand1().bits(operand) });
    }

    fn program_cmd_instruction(&self, cmd: &NorStorageCmd, cookie: &mut LutInstrCookie) {
        let seq_id = cookie.seq_num as usize;
        let mut cmd_mode: FlexSpiLutOpcode = CMD_DDR;

        if cmd.mode == NorStorageCmdMode::SDR {
            cmd_mode = CMD_SDR;
        }
        let bus_width = match cmd.bus_width {
            NorStorageBusWidth::Single => 0,
            NorStorageBusWidth::Dual => 1,
            NorStorageBusWidth::Quad => 2,
            NorStorageBusWidth::Octal => 3,
        };

        self.write_even_instr(seq_id, cmd_mode, cmd.cmd_lb, bus_width);

        cookie.next_instruction();

        if cmd.cmd_ub.is_some() {
            self.write_odd_instr(seq_id, cmd_mode, cmd.cmd_ub.unwrap(), bus_width);
            cookie.next_instruction();
        }
    }

    fn program_addr_instruction(&self, cmd: &NorStorageCmd, cookie: &mut LutInstrCookie) {
        let seq_id = cookie.seq_num as usize;
        let mut cmd_mode: FlexSpiLutOpcode = RADDR_DDR;

        if cmd.mode == NorStorageCmdMode::SDR {
            cmd_mode = RADDR_SDR;
        }
        let bus_width = match cmd.bus_width {
            NorStorageBusWidth::Single => 0,
            NorStorageBusWidth::Dual => 1,
            NorStorageBusWidth::Quad => 2,
            NorStorageBusWidth::Octal => 3,
        };
        if cookie.instr_num == 0 {
            self.write_even_instr(seq_id, cmd_mode, cmd.addr_width.unwrap(), bus_width);
        } else {
            self.write_odd_instr(seq_id, cmd_mode, cmd.addr_width.unwrap(), bus_width);
        }
        cookie.next_instruction();
    }

    fn program_dummy_instruction(&self, cmd: &NorStorageCmd, cookie: &mut LutInstrCookie) {
        let seq_id = cookie.seq_num as usize;
        let mut cmd_mode: FlexSpiLutOpcode = DUMMY_DDR;

        if cmd.mode == NorStorageCmdMode::SDR {
            cmd_mode = DUMMY_SDR;
        }
        let bus_width = match cmd.bus_width {
            NorStorageBusWidth::Single => 0,
            NorStorageBusWidth::Dual => 1,
            NorStorageBusWidth::Quad => 2,
            NorStorageBusWidth::Octal => 3,
        };
        let dummy_val: u8;

        match cmd.dummy {
            NorStorageDummyCycles::Bytes(dummy_bytes) => {
                dummy_val = dummy_bytes;
            }
            NorStorageDummyCycles::Clocks(dummy_cycles) => {
                dummy_val = dummy_cycles;
            }
        }
        if cookie.instr_num == 0 {
            self.write_even_instr(seq_id, cmd_mode, dummy_val, bus_width);
        } else {
            self.write_odd_instr(seq_id, cmd_mode, dummy_val, bus_width);
        }
        cookie.next_instruction();
    }

    fn program_read_data_instruction(&self, cmd: &NorStorageCmd, cookie: &mut LutInstrCookie, data_length: u8) {
        let seq_id = cookie.seq_num as usize;
        let mut cmd_mode: FlexSpiLutOpcode = READ_DDR;

        if cmd.mode == NorStorageCmdMode::SDR {
            cmd_mode = READ_SDR;
        }
        let bus_width = match cmd.bus_width {
            NorStorageBusWidth::Single => 0,
            NorStorageBusWidth::Dual => 1,
            NorStorageBusWidth::Quad => 2,
            NorStorageBusWidth::Octal => 3,
        };

        if cookie.instr_num == 0 {
            self.write_even_instr(seq_id, cmd_mode, data_length, bus_width);
        } else {
            self.write_odd_instr(seq_id, cmd_mode, data_length, bus_width);
        }
        cookie.next_instruction();
    }

    fn program_write_data_instruction(&self, cmd: &NorStorageCmd, cookie: &mut LutInstrCookie, data_length: u8) {
        let seq_id = cookie.seq_num as usize;
        let mut cmd_mode: FlexSpiLutOpcode = WRITE_DDR;

        if cmd.mode == NorStorageCmdMode::SDR {
            cmd_mode = WRITE_SDR;
        }
        let bus_width = match cmd.bus_width {
            NorStorageBusWidth::Single => 0,
            NorStorageBusWidth::Dual => 1,
            NorStorageBusWidth::Quad => 2,
            NorStorageBusWidth::Octal => 3,
        };
        if cookie.instr_num == 0 {
            self.write_even_instr(seq_id, cmd_mode, data_length, bus_width);
        } else {
            self.write_odd_instr(seq_id, cmd_mode, data_length, bus_width);
        }
        cookie.next_instruction();
    }

    fn program_stop_instruction(&self, cookie: &mut LutInstrCookie) {
        let seq_id = cookie.seq_num as usize;
        let cmd_mode: FlexSpiLutOpcode = STOP;

        if cookie.instr_num == 0 {
            self.write_even_instr(seq_id, cmd_mode, 0, 0);
        } else {
            self.write_odd_instr(seq_id, cmd_mode, 0, 0);
        }
        cookie.next_instruction();
    }

    fn program_lut(&self, cmd: &NorStorageCmd, seq_id: usize) {
        let mut cookie = LutInstrCookie {
            seq_num: seq_id * 4,
            instr_num: 0,
        };

        // Unlock LUT
        self.info
            .regs
            .lutkey()
            .modify(|_, w| unsafe { w.key().bits(0x5AF05AF0) });

        self.info.regs.lutcr().write(|w| w.unlock().set_bit());

        // Clear out the LUT
        self.info.regs.lut(seq_id * 4).modify(|_, w| unsafe { w.bits(0) });
        self.info.regs.lut(seq_id * 4 + 1).modify(|_, w| unsafe { w.bits(0) });
        self.info.regs.lut(seq_id * 4 + 2).modify(|_, w| unsafe { w.bits(0) });
        self.info.regs.lut(seq_id * 4 + 3).modify(|_, w| unsafe { w.bits(0) });

        self.program_cmd_instruction(cmd, &mut cookie);

        if cmd.addr_width.is_some() {
            self.program_addr_instruction(cmd, &mut cookie);
        }

        match cmd.dummy {
            NorStorageDummyCycles::Clocks(clk) => {
                if clk > 0 {
                    self.program_dummy_instruction(cmd, &mut cookie);
                }
            }
            _ => {}
        }

        if let Some(transfertype) = cmd.cmdtype {
            match transfertype {
                NorStorageCmdType::Read => {
                    self.program_read_data_instruction(cmd, &mut cookie, cmd.data_bytes.unwrap() as u8);
                }
                NorStorageCmdType::Write => {
                    self.program_write_data_instruction(cmd, &mut cookie, cmd.data_bytes.unwrap() as u8);
                }
            }
        }

        self.program_stop_instruction(&mut cookie);

        // Lock LUT
        self.info
            .regs
            .lutkey()
            .modify(|_, w| unsafe { w.key().bits(0x5AF05AF0) });
        self.info.regs.lutcr().modify(|_, w| w.lock().set_bit());
    }
}

impl FlexspiNorStorageBus<Blocking> {
    fn wait_for_cmd_completion(&mut self) {
        while self.info.regs.intr().read().ipcmddone().bit_is_clear() {}
    }

    fn read_cmd_data(&mut self, mut size: u32, read_data: &mut [u8]) {
        let mut bytes_read = 0;
        let mut byte_cnt = 0;
        let mut num_fifo_slot;

        let error = self.check_transfer_status();

        if let Err(e) = error {
            e.describe(self);
            return;
        }

        if size < self.rx_watermark as u32 {
            // We wont get watermark interrupt. Hence we need to check fifo fill bits
            while (self.info.regs.iprxfsts().read().fill().bits() * 8) < size as u8 {}
            num_fifo_slot = 1;
        } else {
            // Wait for data to reach watermark level
            while self.info.regs.intr().read().iprxwa().bit_is_clear() {}
            num_fifo_slot = (self.rx_watermark / 4) as u32;
        }

        for i in 0..num_fifo_slot {
            let temp = self.info.regs.rfdr(i as usize).read().bits();
            while size > 0 && byte_cnt < 4 {
                read_data[bytes_read as usize] = (temp >> (8 * byte_cnt)) as u8;
                byte_cnt += 1;
                bytes_read += 1;
                size -= 1;
            }
            byte_cnt = 0;
        }

        if size < 4 && size > 0 {
            let temp = self.info.regs.rfdr(num_fifo_slot as usize).read().bits();
            byte_cnt = 0;
            while size > 0 {
                read_data[bytes_read as usize] = (temp >> (8 * byte_cnt)) as u8;
                byte_cnt += 1;
                bytes_read += 1;
                size -= 1;
            }
        }

        // Clear out the water mark level data
        self.info.regs.intr().modify(|_, w| w.iprxwa().clear_bit_by_one());
    }

    fn write_cmd_data(&mut self, mut size: u32, write_data: &[u8]) {
        let num_fifo_slot;
        let mut byte_cnt = 0;

        // wait for space in TX FIFO
        while self.info.regs.intr().read().iptxwe().bit_is_clear() {}

        if size < self.tx_watermark as u32 {
            num_fifo_slot = size / 4;
        } else {
            num_fifo_slot = (self.tx_watermark / 4) as u32;
        }

        for i in 0..num_fifo_slot {
            let mut temp = 0;
            for j in 0..4 {
                temp |= (write_data[byte_cnt] as u32) << (8 * j);
                byte_cnt += 1;
                size -= 1;
            }
            self.info.regs.tfdr(i as usize).write(|w| unsafe { w.bits(temp) });
        }

        if size > 0 && size < 4 {
            let mut temp = 0;
            byte_cnt = 0;
            for j in 0..size {
                temp |= (write_data[byte_cnt] as u32) << (8 * j);
                byte_cnt += 1;
            }
            self.info
                .regs
                .tfdr(num_fifo_slot as usize)
                .write(|w| unsafe { w.bits(temp) });
        }

        // Clear out the water mark level data
        self.info.regs.intr().modify(|_, w| w.iptxwe().clear_bit_by_one());
    }
}

impl FlexSpiConfigurationPort {
    /// Initialize FlexSPI
    pub fn configure_flexspi(&mut self, config: &FlexspiConfig) {
        let regs = self.info.regs;

        // Enable Clock and deassert Reset
        enable_and_reset::<peripherals::FLEXSPI>();

        let sysctl_reg = unsafe { &*crate::pac::Sysctl0::ptr() };
        sysctl_reg
            .pdruncfg1_clr()
            .write(|w| w.flexspi_sram_apd().set_bit().flexspi_sram_ppd().set_bit());

        // These register sequence needs to be updated sequentially. Hence we dont merge the calls
        regs.mcr0().modify(|_, w| w.mdis().clear_bit());
        regs.mcr0().modify(|_, w| w.swreset().set_bit());
        while regs.mcr0().read().swreset().bit_is_set() {}

        //• Set MCR0[MDIS] to 0x1 (Make sure self.flexspi_ref is configured in module stop mode)
        regs.mcr0().modify(|_, w| w.mdis().set_bit());

        //• Configure module control registers: MCR0, MCR1, MCR2. (Don't change MCR0[MDIS])
        regs.mcr0().modify(|_, w| {
            w.rxclksrc()
                .variant(config.rx_sample_clock)
                .dozeen()
                .variant(config.enable_doze)
                .sckfreerunen()
                .variant(config.enable_sck_free_running)
                .hsen()
                .variant(config.enable_half_speed_access)
        });

        regs.mcr1().modify(|_, w| unsafe {
            w.ahbbuswait()
                .bits(config.ahb_config.ahb_bus_timeout_cycle)
                .seqwait()
                .bits(config.seq_timeout_cycle)
        });

        regs.mcr2().modify(|_, w| unsafe {
            w.samedeviceen()
                .variant(config.enable_same_config_for_all)
                .resumewait()
                .bits(config.ahb_config.resume_wait_cycle)
                .sckbdiffopt()
                .variant(config.enable_sck_b_diff_opt)
                .clrahbbufopt()
                .variant(config.ahb_config.enable_clear_ahb_buffer_opt)
        });

        regs.ahbcr().modify(|_, w| {
            w.readaddropt()
                .variant(config.ahb_config.enable_read_address_opt)
                .bufferableen()
                .variant(config.ahb_config.enable_ahb_bufferable)
                .cachableen()
                .variant(config.ahb_config.enable_ahb_cachable)
        });

        if config.ahb_config.enable_ahb_prefetch {
            regs.ahbcr().modify(|_, w| w.prefetchen().set_bit());
        } else {
            regs.ahbcr().modify(|_, w| w.prefetchen().clear_bit());
        }

        regs.ahbrxbuf0cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf1cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf2cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf3cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf4cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf5cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf6cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        regs.ahbrxbuf7cr0().modify(|_, w| unsafe {
            w.mstrid()
                .bits(0)
                .prefetchen()
                .set_bit()
                .bufsz()
                .bits(256)
                .priority()
                .bits(0)
        });

        // • Initialize Flash control registers (FLSHxCR0,FLSHxCR1,FLSHxCR2)
        match self.flash_port {
            FlexSpiFlashPort::PortA => match self.device_instance {
                FlexSpiFlashPortDeviceInstance::DeviceInstance0 => {
                    regs.flsha1cr0().modify(|_, w| unsafe { w.flshsz().bits(0) });
                }
                FlexSpiFlashPortDeviceInstance::DeviceInstance1 => {
                    regs.flsha2cr0().modify(|_, w| unsafe { w.flshsz().bits(0) });
                }
            },
            FlexSpiFlashPort::PortB => match self.device_instance {
                FlexSpiFlashPortDeviceInstance::DeviceInstance0 => {
                    regs.flshb1cr0().modify(|_, w| unsafe { w.flshsz().bits(0) });
                }
                FlexSpiFlashPortDeviceInstance::DeviceInstance1 => {
                    regs.flshb2cr0().modify(|_, w| unsafe { w.flshsz().bits(0) });
                }
            },
        }

        regs.iprxfcr().modify(|_, w| unsafe { w.rxwmrk().bits(0) });
        regs.iptxfcr().modify(|_, w| unsafe { w.txwmrk().bits(0) });
    }

    /// Configure the flash self.flexspi_ref based on the external flash device
    pub fn configure_flexspi_device(&self, device_config: &FlexspiDeviceConfig, flexspi_config: &FlexspiConfig) {
        let regs = self.info.regs;
        let flash_size = device_config.flash_size_kb;

        while regs.sts0().read().arbidle().bit_is_clear() || regs.sts0().read().seqidle().bit_is_clear() {}

        let dll_val = Self::calc_dll_value(&device_config, &flexspi_config);

        if device_config.enable_write_mask {
            regs.flshcr4().modify(|_, w| w.wmopt1().wmopt1_1());
        } else {
            regs.flshcr4().modify(|_, w| w.wmopt1().wmopt1_0());
        }

        match self.flash_port {
            FlexSpiFlashPort::PortA => {
                regs.dllcr(0).modify(|_, w| unsafe { w.bits(dll_val) });
                if device_config.enable_write_mask {
                    regs.flshcr4().modify(|_, w| w.wmena().wmena_1());
                } else {
                    regs.flshcr4().modify(|_, w| w.wmena().wmena_0());
                }
                match self.device_instance {
                    FlexSpiFlashPortDeviceInstance::DeviceInstance0 => {
                        regs.flsha1cr0().modify(|_, w| unsafe { w.flshsz().bits(flash_size) });
                        regs.flshcr1a1().modify(|_, w| unsafe {
                            w.csinterval()
                                .bits(device_config.cs_interval)
                                .tcsh()
                                .bits(device_config.cs_hold_time)
                                .tcss()
                                .bits(device_config.cs_setup_time)
                                .cas()
                                .bits(device_config.columnspace)
                                .wa()
                                .bit(device_config.enable_word_address)
                                .csintervalunit()
                                .variant(device_config.cs_interval_unit)
                        });
                        regs.flshcr2a1()
                            .modify(|_, w| w.awrwaitunit().variant(device_config.ahb_write_wait_unit));

                        if device_config.ard_seq_number > 0 {
                            regs.flshcr2a1().modify(|_, w| unsafe {
                                w.ardseqnum()
                                    .bits(device_config.ard_seq_number - 1)
                                    .ardseqid()
                                    .bits(device_config.ard_seq_index)
                            });
                        }
                    }

                    FlexSpiFlashPortDeviceInstance::DeviceInstance1 => {
                        regs.flsha2cr0().modify(|_, w| unsafe { w.flshsz().bits(flash_size) });
                        regs.flshcr1a2().modify(|_, w| unsafe {
                            w.csinterval()
                                .bits(device_config.cs_interval)
                                .tcsh()
                                .bits(device_config.cs_hold_time)
                                .tcss()
                                .bits(device_config.cs_setup_time)
                                .cas()
                                .bits(device_config.columnspace)
                                .wa()
                                .bit(device_config.enable_word_address)
                                .csintervalunit()
                                .variant(device_config.cs_interval_unit)
                        });
                        regs.flshcr2a2()
                            .modify(|_, w| w.awrwaitunit().variant(device_config.ahb_write_wait_unit));

                        if device_config.ard_seq_number > 0 {
                            regs.flshcr2a2().modify(|_, w| unsafe {
                                w.ardseqnum()
                                    .bits(device_config.ard_seq_number - 1)
                                    .ardseqid()
                                    .bits(device_config.ard_seq_index)
                            });
                        }
                    }
                }
            }
            FlexSpiFlashPort::PortB => {
                regs.dllcr(1).modify(|_, w| unsafe { w.bits(dll_val) });
                if device_config.enable_write_mask {
                    regs.flshcr4().modify(|_, w| w.wmenb().wmenb_1());
                } else {
                    regs.flshcr4().modify(|_, w| w.wmenb().wmenb_0());
                }
                match self.device_instance {
                    FlexSpiFlashPortDeviceInstance::DeviceInstance0 => {
                        regs.flshb1cr0().modify(|_, w| unsafe { w.flshsz().bits(flash_size) });
                        regs.flshcr1b1().modify(|_, w| unsafe {
                            w.csinterval()
                                .bits(device_config.cs_interval)
                                .tcsh()
                                .bits(device_config.cs_hold_time)
                                .tcss()
                                .bits(device_config.cs_setup_time)
                                .cas()
                                .bits(device_config.columnspace)
                                .wa()
                                .bit(device_config.enable_word_address)
                                .csintervalunit()
                                .variant(device_config.cs_interval_unit)
                        });
                        regs.flshcr2b1()
                            .modify(|_, w| w.awrwaitunit().variant(device_config.ahb_write_wait_unit));

                        if device_config.ard_seq_number > 0 {
                            regs.flshcr2b1().modify(|_, w| unsafe {
                                w.ardseqnum()
                                    .bits(device_config.ard_seq_number - 1)
                                    .ardseqid()
                                    .bits(device_config.ard_seq_index)
                            });
                        }
                    }
                    FlexSpiFlashPortDeviceInstance::DeviceInstance1 => {
                        regs.flshb2cr0().modify(|_, w| unsafe { w.flshsz().bits(flash_size) });
                        regs.flshcr1b2().modify(|_, w| unsafe {
                            w.csinterval()
                                .bits(device_config.cs_interval)
                                .tcsh()
                                .bits(device_config.cs_hold_time)
                                .tcss()
                                .bits(device_config.cs_setup_time)
                                .cas()
                                .bits(device_config.columnspace)
                                .wa()
                                .bit(device_config.enable_word_address)
                                .csintervalunit()
                                .variant(device_config.cs_interval_unit)
                        });
                        regs.flshcr2b2()
                            .modify(|_, w| w.awrwaitunit().variant(device_config.ahb_write_wait_unit));

                        if device_config.ard_seq_number > 0 {
                            regs.flshcr2b2().modify(|_, w| unsafe {
                                w.ardseqnum()
                                    .bits(device_config.ard_seq_number - 1)
                                    .ardseqid()
                                    .bits(device_config.ard_seq_index)
                            });
                        }
                    }
                }
            }
        }

        // Enable the module
        regs.mcr0().modify(|_, w| w.mdis().clear_bit());

        //Errata ERR011377 - need to delay at least 100 NOPs to ensure the DLL is locked.
        // match self.flash_port {
        //     FlexSpiFlashPort::PortA => {
        //         while regs.sts2().read().aslvlock().bit_is_clear() && regs.sts2().read().areflock().bit_is_clear() {
        //             // Wait for DLL lock
        //         }

        //         #[allow(unused_variables)]
        //         for i in 0..100 {
        //             asm::nop();
        //         }
        //     }
        //     FlexSpiFlashPort::PortB => {
        //         while regs.sts2().read().bslvlock().bit_is_clear() && regs.sts2().read().breflock().bit_is_clear() {
        //             // Wait for DLL lock
        //         }

        //         #[allow(unused_variables)]
        //         for i in 0..100 {
        //             asm::nop();
        //         }
        //     }
        // }
    }

    fn calc_dll_value(device_config: &FlexspiDeviceConfig, flexspi_config: &FlexspiConfig) -> u32 {
        let is_unified_config;
        let flexspi_dll_value;
        let mut dll_value;
        let temp;

        let rx_sample_clock = flexspi_config.rx_sample_clock;
        match rx_sample_clock {
            Rxclksrc::Rxclksrc0 => {
                is_unified_config = true;
            }
            Rxclksrc::Rxclksrc1 => {
                is_unified_config = true;
            }
            Rxclksrc::Rxclksrc3 => {
                is_unified_config = device_config.is_sck2_enabled;
            }
        }

        if is_unified_config {
            flexspi_dll_value = 0x100; /* 1 fixed delay cells in DLL delay chain) */
        } else if device_config.flexspi_root_clk >= 100000000 {
            /* DLLEN = 1, SLVDLYTARGET = 0xF, */
            flexspi_dll_value = 0x1 | (0xF << 3);
        } else {
            temp = (device_config.data_valid_time) as u32 * 1000; /* Convert data valid time in ns to ps. */
            dll_value = temp / 75;
            if dll_value * 75 < temp {
                dll_value += 1;
            }
            flexspi_dll_value = (0x1 << 8) | ((dll_value & 0x78) << 9); // TODO: remove hardcoding
        }
        flexspi_dll_value
    }
}

impl FlexspiNorStorageBus<Blocking> {
    #[allow(clippy::too_many_arguments)]
    /// Create a new FlexSPI instance in blocking mode with RAM execution
    pub fn new_blocking<T: Instance>(
        _inst: T,
        data0: Option<impl FlexSpiDataPin>,
        data1: Option<impl FlexSpiDataPin>,
        data2: Option<impl FlexSpiDataPin>,
        data3: Option<impl FlexSpiDataPin>,
        data4: Option<impl FlexSpiDataPin>,
        data5: Option<impl FlexSpiDataPin>,
        data6: Option<impl FlexSpiDataPin>,
        data7: Option<impl FlexSpiDataPin>,
        clk: impl FlexSpiClkPin,
        cs: impl FlexSpiCsPin,
        port: FlexSpiFlashPort,
        bus_width: FlexSpiBusWidth,
        dev_instance: FlexSpiFlashPortDeviceInstance,
    ) -> Self {
        if let Some(data0) = data0 {
            data0.config_pin();
        }
        if let Some(data1) = data1 {
            data1.config_pin();
        }
        if let Some(data2) = data2 {
            data2.config_pin();
        }
        if let Some(data3) = data3 {
            data3.config_pin();
        }
        if let Some(data4) = data4 {
            data4.config_pin();
        }
        if let Some(data5) = data5 {
            data5.config_pin();
        }
        if let Some(data6) = data6 {
            data6.config_pin();
        }
        if let Some(data7) = data7 {
            data7.config_pin();
        }

        cs.config_pin();
        clk.config_pin();

        Self {
            info: T::info(),
            rx_watermark: 8, // 8 bytes
            tx_watermark: 8, // 8 bytes
            _mode: core::marker::PhantomData,
            configport: FlexSpiConfigurationPort {
                info: T::info(),
                _bus_width: bus_width,
                device_instance: dev_instance,
                flash_port: port,
            },
        }
    }
}

macro_rules! impl_data_pin {
    ($peri:ident, $fn: ident, $invert: ident, $pull: ident) => {
        impl FlexSpiDataPin for crate::peripherals::$peri {
            fn config_pin(&self) {
                self.set_function(crate::iopctl::Function::$fn)
                    .set_pull(crate::iopctl::Pull::None)
                    .set_slew_rate(crate::gpio::SlewRate::Slow)
                    .set_drive_strength(crate::gpio::DriveStrength::Normal)
                    .disable_analog_multiplex()
                    .set_drive_mode(crate::gpio::DriveMode::$pull)
                    .set_input_inverter(crate::gpio::Inverter::$invert);
            }
        }
    };
}

macro_rules! impl_cs_pin {
    ($peri:ident, $fn: ident) => {
        impl FlexSpiCsPin for crate::peripherals::$peri {
            fn config_pin(&self) {
                self.set_function(crate::iopctl::Function::$fn)
                    .set_pull(crate::iopctl::Pull::None)
                    .set_slew_rate(crate::gpio::SlewRate::Standard)
                    .set_drive_strength(crate::gpio::DriveStrength::Normal)
                    .set_drive_mode(crate::gpio::DriveMode::PushPull)
                    .set_input_inverter(crate::gpio::Inverter::Disabled);
            }
        }
    };
}

macro_rules! impl_clk_pin {
    ($peri:ident, $fn: ident) => {
        impl FlexSpiClkPin for crate::peripherals::$peri {
            fn config_pin(&self) {
                self.set_function(crate::iopctl::Function::$fn)
                    .set_pull(crate::iopctl::Pull::None)
                    .enable_input_buffer()
                    .set_slew_rate(crate::gpio::SlewRate::Standard)
                    .set_drive_strength(crate::gpio::DriveStrength::Full)
                    .disable_analog_multiplex()
                    .set_drive_mode(crate::gpio::DriveMode::PushPull)
                    .set_input_inverter(crate::gpio::Inverter::Disabled);
            }
        }
    };
}

/// FlexSPI Data Pins
pub trait FlexSpiDataPin: Pin + sealed::Sealed + crate::Peripheral {
    /// Configure FlexSPI Data Pin
    fn config_pin(&self);
}
/// FlexSPI CS Pin
pub trait FlexSpiCsPin: Pin + sealed::Sealed + crate::Peripheral {
    /// Configure FlexSPI CS Pin
    fn config_pin(&self);
}
/// FlexSPI Clock Pin
pub trait FlexSpiClkPin: Pin + sealed::Sealed + crate::Peripheral {
    /// Configure FlexSPI Clock Pin
    fn config_pin(&self);
}

impl_data_pin!(PIO1_11, F6, Disabled, PushPull); // PortB-DATA0
impl_data_pin!(PIO1_12, F6, Disabled, PushPull); // PortB-DATA1
impl_data_pin!(PIO1_13, F6, Disabled, PushPull); // PortB-DATA2
impl_data_pin!(PIO1_14, F6, Disabled, PushPull); // PortB-DATA3
impl_data_pin!(PIO2_17, F6, Disabled, PushPull); // PortB-DATA4
impl_data_pin!(PIO2_18, F6, Disabled, PushPull); // PortB-DATA5
impl_data_pin!(PIO2_22, F6, Disabled, PushPull); // PortB-DATA6
impl_data_pin!(PIO2_23, F6, Disabled, PushPull); // PortB-DATA7
impl_cs_pin!(PIO2_19, F6); // PortB-CS0
impl_cs_pin!(PIO2_21, F6); // PortB-CS1
impl_clk_pin!(PIO1_29, F5); // PortB-SCLK

impl_cs_pin!(PIO1_19, F1); // PortA-CS0
impl_clk_pin!(PIO1_18, F1); // PortA-SCLK
impl_data_pin!(PIO1_20, F1, Disabled, PushPull); // PortA-DATA0
impl_data_pin!(PIO1_21, F1, Disabled, PushPull); // PortA-DATA1
impl_data_pin!(PIO1_22, F1, Disabled, PushPull); // PortA-DATA2
impl_data_pin!(PIO1_23, F1, Disabled, PushPull); // PortA-DATA3
impl_data_pin!(PIO1_24, F1, Disabled, PushPull); // PortA-DATA4
impl_data_pin!(PIO1_25, F1, Disabled, PushPull); // PortA-DATA5
impl_data_pin!(PIO1_26, F1, Disabled, PushPull); // PortA-DATA6
impl_data_pin!(PIO1_27, F1, Disabled, PushPull); // PortA-DATA7
